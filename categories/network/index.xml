<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Network on CC&#39;s Trip</title>
    <link>https://cctrip.tech/categories/network/</link>
    <description>Recent content in Network on CC&#39;s Trip</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 08 Aug 2018 17:55:28 +0800</lastBuildDate><atom:link href="https://cctrip.tech/categories/network/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>理解TCP协议</title>
      <link>https://cctrip.tech/posts/deep_tcp/</link>
      <pubDate>Wed, 08 Aug 2018 17:55:28 +0800</pubDate>
      
      <guid>https://cctrip.tech/posts/deep_tcp/</guid>
      <description>1. 介绍    TCP协议是个复杂的东西，但是对学习网络知识也好，排查网络问题也好，优化网络性能也是，又是一个不得不啃的东西。自己也反反复复的看了不少文章，书籍和RFC文档，这次，想总结一下自己这些年对TCP的理解，方便后续查阅。
1.1 TCP是什么？    我们知道，IP协议是不可靠的，它不保证IP数据报文能成功达到目的地，它只提供最好的传输服务。而TCP的出现就是为了在IP协议不可靠的传输上面提供可靠的传输服务。
 wiki上的定义，TCP是在通过IP网络进行通信的主机上运行的应用程序之间，提供可靠，有序且经过错误检查的八位位组（字节）流交付。
 在RFC 793中，定义了为了实现TCP服务，需要做什么：
  Basic data transfer
TCP通过将一定量的字节打包成在internet系统上传输的分片，能够在用户之间在两个方向上传输连续的字节流。通常情况下，TCPs决定什么时候阻塞以及前推数据。有时候用户需要确保他们所提交给TCP的所有数据都被传输。基于这个目的，定义了push功能。为了确认提交给TCP的数据报确实被传送了，发送用户指示数据必须被推给接收用户。Push导致了TCPs立即前推和投递数据给接收者。确切的push点对接收用户可能不可见，且push功能不提供一个记录边界标识。
  Reliability
为确保可靠性，TCP必须能解决由通讯网络造成的数据损坏、丢失、重复、或者乱序问题。TCP通过给每个字节分配序列号，并要求接收者必须确认(ACK)的机制来达到这个目的。(确认机制)，如果在超时时间间隔内没有收到ACK，将重传该”数据“。（重传机制）。对于接收方而言，序列号用来对可能接收到的乱序的、重复的数据段进行正确的排序并且消除重复数据。对于损坏的数据而言，通过在每个传输的数据段中添加checksum，并且在接收端进行检查来进行丢弃处理。
  Flow control
TCP为接受方提供了一种管理发送方发送数据量大小的机制。通过在每次返回确认信息（ACK）的时候增加一个窗口，这个窗口表示接收方最后一次成功接收之后还可以接收的字节数量。
  Multiplexing
为了允许在一个单独的主机里多个进程同时使用TCP通信机制，TCP提供了一套地址和端口。从internet通信层同网络和宿主地址连接，这形成了一个socket。一对socket标识了一个连接。也就是说，一个socket可能同时被使用在多个连接中。绑定端口到进程被每个主机单独处理。是，将常用的进程（如“logger”或者时间服务）隶属于众所皆知的socket被证明是有用的。这些服务就可以通过已知的地址获取到。建立和学习其它进程的端口地址可能包括更加动态的机制。
  Connections
上面描述的可靠性和流量控制机制要求所有的TCP为每个数据流发起和维护某些状态信息。这些信息的结合体，包括sockets，系列号，和窗口大小，被称为一个连接。每个连接被一套指定两端的socket唯一指定。当两个进程需要通信的时候，他们的TCPs必须首先建立一个连接（在每一端初始化状态信息）。当通信完成的时候，连接终止或者关闭以释放资源用于其它用途。由于连接必须在不可靠的主机和不可靠的internet通信系统上建立，一个带有基于时钟的系列号的握手机制被用来避免连接的错误初始化。
  Precedence and Security
TCP用户可以指示通信的安全性和优先级。当这些特性不需要的时候，规定采用缺省值。
  1.2 数据封装    首先，我们要知道，真实数据是通过层层封装后传输出去的，每一层都会添加自己的协议信息到header里面加上数据形成新的数据&amp;quot;包&amp;quot;，方便对方解析。接下来，我们来了解TCP的相关数据信息。
 2. TCP基本信息    2.1 Header    在TCP传输中，是以段(segment)为一个单位进行传输的，一个TCP段由header和data部分组成，header由10个固定字段(共20字节)和一个可选扩展字段组成：
  Source port (16 bits)</description>
    </item>
    
    <item>
      <title>谈谈HTTP</title>
      <link>https://cctrip.tech/posts/http/</link>
      <pubDate>Sun, 29 May 2016 17:55:28 +0800</pubDate>
      
      <guid>https://cctrip.tech/posts/http/</guid>
      <description>写在前面    如今网络已经无处不在，人们通过网络获取浏览各种信息，其中，大部分都是通过浏览器访问各种网页来获取我们想要的信息，那么浏览器与网页(服务端)究竟是如何通信的呢？这就得从HTTP协议说起了，浏览器获取网页信息都是基于HTTP协议来处理的。
 概念    HTTP（HyperText Transfer Protocol，超文本传输协议）是互联网上应用最为广泛的一种网络协议。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。其具有如下特点：
  支持客户/服务器模式。
  简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
  灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
  无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
  无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快
  PS：尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。
 工作流程    HTTP协议的通信过程永远是客户端发起请求(request)，服务器回送响应(respone)，如下图所示：
一个完整的HTTP操作称为一个事务，其流程可分为四步：
  建立连接(TCP三次握手)
  客户端发送一个请求报文给服务器
  服务器响应对应信息
  客户端接收信息，然后断开连接
   请求和响应详解    请求报文      请求行：由请求方法、URL和HTTP版本组成
eg：GET /index.html HTTP/1.1
  请求方法</description>
    </item>
    
    <item>
      <title>谈谈DNS</title>
      <link>https://cctrip.tech/posts/dns/</link>
      <pubDate>Sat, 21 May 2016 17:55:28 +0800</pubDate>
      
      <guid>https://cctrip.tech/posts/dns/</guid>
      <description>写在前面    目前，我们大部分的网络通信都是基于TCP/IP协议的，而TCP/IP又基于IP地址作为唯一标识进行通信，随着需要记忆的IP地址数量的增多，肯定会超出我们的记忆能力范围，但如果使用一种利于人们的记忆的方式，如域名，例如&amp;quot;www.google.com&amp;quot;，我们便可以轻松的记忆这种方式的标识，而不是繁杂的数字。而DNS(域名系统)就是为了可以使用这种方式提供服务的。
 概念    DNS(Domain Name System)，域名系统，它是因特网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。
DNS Domain Namespace，DNS域命名空间，是一种分层树状结构，其格式如下:&amp;ldquo;www.google.com&amp;rdquo;,以点&amp;quot;.&amp;ldquo;为分隔。结构如图所示：
  根域：绝对域名(FQDN)，以点&amp;rdquo;.&amp;ldquo;结尾的域名
  顶级域：用来指示某个国家/地区或组织使用的名称的类型名称，例如.com
  二级域：个人或组织在因特网上使用的注册名称，例如google.com
  子域：已注册的二级域名派生的域名，一般就是网站名，例如www.google.com
  主机名：标识网络上的特定计算机，例如h1.www.google.com
  DNS资源记录：(即映射关系，通常由域名管理员进行配置)，常见类型如下：
  SOA：起始授权机构
  NS：名称服务器
  MX：邮件服务器
  A：IP地址(最常用，映射IP地址)
  CNAME：别名(较常用，映射到其他域名)
   DNS工作原理    当我们请求一个域名时，会通过DNS服务器将域名解析成IP访问最终的主机，那么，DNS是如何查询到域名所对应的IP并返回给我们的呢？请工作机制如图所示：
当我们请求一个域名时，直到获取到IP地址，整个过程是如何工作的？以请求www.codecc.xyz为例：
  首先，我们的主机会去查找本地的hosts文件和本地DNS解析器缓存，如果hosts文件和本地DNS缓存存在www.codecc.xyz和IP的映射关系，则完成域名解析，请求该IP地址，否则进入第二步。
  当hosts和本地DNS解析器缓存都没有对应的网址映射关系，则会根据机器(/etc/reslove.conf)配置的本地DNS服务器进行查询，此服务器收到查询时，如果要查询的域名在本地配置区域资源或者缓存中存在映射关系，则跳到步骤9，将解析结果直接返回给客户机。
  PS：一二步骤为递归查询，其余步骤为迭代查询
 若本地DNS服务器不存在该域名的映射关系，就把请求发送至13台根DNS服务器。
  根DNS服务器会判断这个域名(.</description>
    </item>
    
    <item>
      <title>初识网络通信</title>
      <link>https://cctrip.tech/posts/network_comm/</link>
      <pubDate>Wed, 18 May 2016 17:55:28 +0800</pubDate>
      
      <guid>https://cctrip.tech/posts/network_comm/</guid>
      <description>写在前面    在计算机刚出现的时候，只能在本机进行一些运算处理，想将一台计算机中的数据转移到另一台计算机中，需要通过外部存储介质来传输，例如磁带、软盘。而网络技术的出现，使得计算机间可以通过一些传输介质(网线、光纤等)，实现快速的数据传输和信息交互。如今，网络已无处不在，那么，计算机之间究竟是如何通信的呢？下面会通过一些基础的网络知识来简单理解计算机之间的通信过程。
 网络通信模型     网络通信模型是一种概念模型和框架，旨在使各种计算机在世界范围内互连为网络。其中有OSI七层模型和TCP/IP四层模型，现在大部分网络通信都是以TCP/IP四层模型为基础的。
 它们的对应层次如下图：
 OSI有七层：从上到下依次为应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
  TCP/IP有四层：从上到下依次为应用层、传输层、互连层(网络层)、网络接口层(链路层)。
 因为目前大部分TCP/IP模型，所以就以TCP/IP为例，我们来理解下数据间的通信，下图是两台计算机通信的数据的传输过程：
 数据封装    在详细了解TCP/IP每一层各自的作用前，先要理解数据封装的概念，数据在通过网络接口传送出去前，会经过层层封装，每层都会在前面的基础上添加自己的信息，在传输到对方计算机后，又会被层层进行解封装后得到最后的数据。其过程如下图所示：
 TCP/IP参考模型     TCP/IP参考模型是一个抽象的分层模型，这个模型中，所有的TCP/IP系列网络协议都被归类到4个抽象的&amp;quot;层&amp;quot;中。每一抽象层创建在低一层提供的服务上，并且为高一层提供服务。 完成一些特定的任务需要众多的协议协同工作，这些协议分布在参考模型的不同层中的，因此有时称它们为一个协议栈。
  应用层(Application Layer)     该层包括所有和应用程序协同工作，利用基础网络交换应用程序专用的数据的协议。 应用层是大多数普通与网络相关的程序为了通过网络与其他程序通信所使用的层。这个层的处理过程是应用特有的；数据从网络相关的程序以这种应用内部使用的格式进行传送，然后被编码成标准协议的格式。
  常见的应用层协议有HTTP、FTP、DNS、SNMP(基于UDP)   传输层(Transport Layer)     主要为两台主机上的应用程序提供端到端的通信，包括TCP协议（传输控制协议）和UDP（用户数据报协议）。 端口号由此层提供，且在一台计算机中具有唯一性。
  UDP为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。任何必需的可靠性必须由应用层来提供。
  TCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等,由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。
 因为TCP是一种面向连接的协议，所以两个在使用TCP的应用在彼此交换数据前必须先建立一个TCP连接，也就是有名的TCP三次握手，如下图所示：
建立连接协议过程：（TCP三次握手协议）
 客户端发送一个SYN段指明客户打算连接的服务器的端口，以及初始序号（ISN）。 服务器发回包含服务器的初始序号的SYN报文段作为应答。同时，将确认序号设置为客户的ISN加1以对客户的SYN报文段进行确认。一个SYN占用一个序号。 客户将确认序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认。   网络层(Internet Layer)     处理分组在网络中的活动。网络层协议包括IP协议（网际协议），ICPM协议（Internet互联网控制报文协议），以及IGMP协议（Internet组管理协议），其中的IP协议身是TCP/IP协议簇中最为核心的协议。IP提供的是不可靠、无连接的数据包传送服务。</description>
    </item>
    
  </channel>
</rss>
